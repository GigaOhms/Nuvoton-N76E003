C51 COMPILER V9.60.0.0   GPIO                                                              01/12/2024 10:26:19 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE GPIO
OBJECT MODULE PLACED IN .\Output\GPIO.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\GPIO.C OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Include;..\..\LIB) DEF
                    -INE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\GPIO.lst) OBJECT(.\Output\GPIO.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* Copyright(c) 2017 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   4          /*                                                                                                        
             - */
   5          /*--------------------------------------------------------------------------------------------------------
             --*/
   6          
   7          //********************************************************************************************************
             -***
   8          //  Website: http://www.nuvoton.com
   9          //  E-Mail : MicroC-8bit@nuvoton.com
  10          //  Date   : Jan/21/2017
  11          //********************************************************************************************************
             -***
  12          
  13          //********************************************************************************************************
             -***
  14          //  File Function: N76E003 GPIO demo code
  15          //********************************************************************************************************
             -***
  16          #include "N76E003.h"
  17          #include "SFR_Macro.h"
  18          #include "Function_define.h"
  19          #include "Common.h"
  20          #include "Delay.h"
  21          
  22          #include "avr.h"
  23          #include "TM1637.h"
  24          #include "ModbusRTU.h"
  25          #include "I2Ceeprom.h"
  26          
  27          
  28          /*------------------------------------------------
  29          The main C function.  Program execution starts
  30          here after stack initialization.
  31          ------------------------------------------------*/
  32          
  33          #define CLK 11
  34          #define DIO 12
  35          
  36          TM1637 display;
  37          
  38          void showValue(int so)
  39          {
  40   1        int xdata d = so / 1000;
  41   1        int xdata c = ((so / 100) % 10);
  42   1        int xdata b = (so % 100) / 10;
  43   1        int xdata a = so % 10;
  44   1      
  45   1        uint8_t datas[] = { 0xff, 0xff, 0xff, 0xff };
C51 COMPILER V9.60.0.0   GPIO                                                              01/12/2024 10:26:19 PAGE 2   

  46   1        datas[0] = TM1637_encodeDigit(d);
  47   1        datas[1] = TM1637_encodeDigit(c);
  48   1        datas[2] = TM1637_encodeDigit(b);
  49   1        datas[3] = TM1637_encodeDigit(a);
  50   1        TM1637_setSegments(&display, datas);
  51   1      }
  52          
  53          
  54          // ----------------- DATA SLA --------------------------
  55          uint8_t error1 = 0, error2 = 0, error3 = 0, error4 = 0;
  56          uint8_t id = 0x1;
  57          uint16_t counter = 0;
  58          
  59          
  60          // -------------- SERIAL MODBUS VARIABLE -------------------
  61          #define sumSize 15U             // them 2 byte checkSum la 17
  62          #define sizeData 14U
  63          
  64          uint8_t xdata dataSend[15];     // 3 byte resigter and u16data[]
  65          
  66          bit checkID = 0;
  67          bit checkSend = 0;
  68          bit checkWrite = 0;
  69          bit checkSerial = 0;
  70          
  71          uint8_t xdata reciveCounter = 0;
  72          uint8_t xdata reciveData[8];
  73          uint32_t xdata serialTime = 0;
  74          
  75          #define serialTimeout 30UL
  76          
  77          uint8_t serial_available() {
  78   1              return RI ? 1 : 0;
  79   1      }
  80          
  81          uint8_t serial_read() {
  82   1              uint8_t c = SBUF;
  83   1              RI = 0;
  84   1              return c;
  85   1      }
  86          
  87          
  88          // -------------- GPIO SETUP -----------------------
  89          #define BT_UP 4
  90          #define BT_DW 10
  91          #define BT_E1 0
  92          #define BT_E2 3
  93          #define BT_E3 1
  94          #define BT_E4 2
  95          
  96          bit S_BT_UP = 0;
  97          bit S_BT_DW = 0;
  98          bit S_BT_E1 = 0;
  99          bit S_BT_E2 = 0;
 100          bit S_BT_E3 = 0;
 101          bit S_BT_E4 = 0;
 102          
 103          
 104          
 105          void showError(uint8_t error, uint8_t value) {
 106   1        uint8_t datas[] = { 0, 0, 0, 0 };
 107   1        datas[0] = TM1637_encodeDigit(14);
C51 COMPILER V9.60.0.0   GPIO                                                              01/12/2024 10:26:19 PAGE 3   

 108   1        datas[1] = TM1637_encodeDigit(error);
 109   1        datas[2] = 0x00;                      // 0x40 is '-'                  // 0x00 is ' '
 110   1        datas[3] = TM1637_encodeDigit(value);
 111   1        TM1637_setSegments(&display, datas);
 112   1        Timer0_Delay1ms(500);
 113   1      }
 114          
 115          void dataUpdate() {
 116   1              dataSend[4] = lowByte(error1);
 117   1              dataSend[6] = lowByte(error2);
 118   1              dataSend[8] = lowByte(error3);
 119   1              dataSend[10] = lowByte(error4);
 120   1              dataSend[11] = highByte(counter);
 121   1              dataSend[12] = lowByte(counter);
 122   1              dataSend[14] = lowByte(id);
 123   1      }
 124          
 125          
 126          volatile uint32_t xdata millis = 0;
 127          volatile uint32_t xdata led_time;
 128          
 129          void Timer2_ISR (void) interrupt 5
 130          {
 131   1              clr_TF2;                                             //Clear Timer2 Interrupt Flag
 132   1              millis++;
 133   1      }
 134          
 135          
 136          
 137          // I2C 
 138          #define addrE1  0
 139          #define addrE2  1
 140          #define addrE3  2
 141          #define addrE4  3
 142          #define addrCNT 4
 143          #define addrID  6
 144          
 145          
 146          
 147          void main (void) {              
 148   1              InitialUART0_Timer3(9600);      
 149   1              I2C_Init();
 150   1              
 151   1              /*
 152   1              if (I2C_Write(addrE1, 1));
 153   1              Timer0_Delay1ms(1);
 154   1              if (I2C_Write(addrE2, 1));
 155   1              Timer0_Delay1ms(1);
 156   1              if (I2C_Write(addrE3, 1));
 157   1              Timer0_Delay1ms(1);
 158   1              if (I2C_Write(addrE4, 1));
 159   1              Timer0_Delay1ms(1);
 160   1              if (I2C_Write(addrID, 1));
 161   1              Timer0_Delay1ms(1);
 162   1              if (I2C_WriteInt(addrCNT, 99));
 163   1              Timer0_Delay1ms(1);
 164   1              */
 165   1              
 166   1              
 167   1              
 168   1              if (I2C_Read(addrE1, &error1));
 169   1              if (I2C_Read(addrE2, &error2));
C51 COMPILER V9.60.0.0   GPIO                                                              01/12/2024 10:26:19 PAGE 4   

 170   1              if (I2C_Read(addrE3, &error3));
 171   1              if (I2C_Read(addrE4, &error4));
 172   1              if (I2C_Read(addrID, &id));
 173   1              if (I2C_ReadInt(addrCNT, &counter));
 174   1      
 175   1              Send_Data_To_UART0(id);
 176   1              
 177   1              // --------------- ISR timer2 1kHz -----------------------
 178   1              TIMER2_DIV_4;
 179   1              TIMER2_Auto_Reload_Delay_Mode;
 180   1              RCMP2L = TIMER_DIV4_VALUE_1ms;
 181   1              RCMP2H = TIMER_DIV4_VALUE_1ms >> 8;
 182   1              TH2 = 0;
 183   1              TL2 = 0;
 184   1              set_TR2;
 185   1              set_ET2;
 186   1          set_EA;             // Enable global interrupts
 187   1              
 188   1              // ------------------- GPIO Config ------------------------
 189   1              pinMode(BT_UP, INPUT);
 190   1              pinMode(BT_DW, INPUT);
 191   1              pinMode(BT_E1, INPUT);
 192   1              pinMode(BT_E2, INPUT);
 193   1              pinMode(BT_E3, INPUT);
 194   1              pinMode(BT_E4, INPUT);
 195   1              
 196   1              TM1637_init(&display, CLK, DIO);
 197   1              Timer0_Delay1ms(100);
 198   1              
 199   1              TM1637_setBrightness(&display, 0x0f); // led 7 doan
 200   1              showValue(counter);
 201   1              
 202   1              dataSend[0] = lowByte(id);
 203   1              dataSend[1] = 0x3;              // value READ HOLDING REGISTERS
 204   1              dataSend[2] = 0xc;              // size of Data
 205   1              dataSend[3] = 0x0;              //highByte(error1);
 206   1              dataSend[5] = 0x0;              //highByte(error2);
 207   1              dataSend[7] = 0x0;              //highByte(error3);
 208   1              dataSend[9] = 0x0;              //highByte(error4);
 209   1              dataSend[13] = 0x0;             //highByte(id);
 210   1      
 211   1              dataUpdate();
 212   1              led_time = millis;
 213   1              serialTime = millis;
 214   1              
 215   1              while(1)
 216   1              {       
 217   2                      if (digitalRead(BT_UP) == 0 && S_BT_UP == 0) {
 218   3                              S_BT_UP = 1;
 219   3                              counter = (counter >= 9999) ? counter : counter + 1;
 220   3                              dataUpdate();
 221   3                              showValue(counter);
 222   3                              Timer0_Delay1ms(200);
 223   3                              if (I2C_WriteInt(addrCNT, counter))
 224   3                                      Timer0_Delay1ms(1);
 225   3                      } else if (digitalRead(BT_UP) == 1) S_BT_UP = 0;
 226   2                      
 227   2                      if (digitalRead(BT_DW) == 0 && S_BT_DW == 0) {
 228   3                              S_BT_DW = 1;
 229   3                              counter = (counter == 0) ? counter : counter - 1;
 230   3                              dataUpdate();
 231   3                              showValue(counter);
C51 COMPILER V9.60.0.0   GPIO                                                              01/12/2024 10:26:19 PAGE 5   

 232   3                              Timer0_Delay1ms(200);
 233   3                              if (I2C_WriteInt(addrCNT, counter))
 234   3                                      Timer0_Delay1ms(1);
 235   3                      } else if (digitalRead(BT_DW) == 1) S_BT_DW = 0;
 236   2                      
 237   2                      if (digitalRead(BT_E1) == 0 && S_BT_E1 == 0) {
 238   3                              S_BT_E1 = 1;
 239   3                              error1 = (error1 == 1) ? 0 : 1;
 240   3                              dataUpdate();
 241   3                              showError(1, error1);
 242   3                              if (I2C_Write(addrE1, error1))
 243   3                                      Timer0_Delay1ms(1);
 244   3                              Timer0_Delay1ms(200);
 245   3                              showValue(counter);
 246   3                      } else if (digitalRead(BT_E1) == 1) S_BT_E1 = 0;
 247   2      
 248   2                      if (digitalRead(BT_E2) == 0 && S_BT_E2 == 0) {
 249   3                              S_BT_E2 = 1;
 250   3                              error2 = (error2 == 1) ? 0 : 1;
 251   3                              dataUpdate();
 252   3                              showError(2, error2);
 253   3                              if (I2C_Write(addrE2, error2))
 254   3                                      Timer0_Delay1ms(1);
 255   3                              Timer0_Delay1ms(200);
 256   3                              showValue(counter);
 257   3                      } else if (digitalRead(BT_E2) == 1) S_BT_E2 = 0;
 258   2                      
 259   2                      if (digitalRead(BT_E3) == 0 && S_BT_E3 == 0) {
 260   3                              S_BT_E3 = 1;
 261   3                              error3 = (error3 == 1) ? 0 : 1;
 262   3                              dataUpdate();
 263   3                              showError(3, error3);
 264   3                              if (I2C_Write(addrE3, error3))
 265   3                                      Timer0_Delay1ms(1);
 266   3                              Timer0_Delay1ms(200);
 267   3                              showValue(counter);
 268   3                      } else if (digitalRead(BT_E3) == 1) S_BT_E3 = 0;
 269   2                      
 270   2                      if (digitalRead(BT_E4) == 0 && S_BT_E4 == 0) {
 271   3                              S_BT_E4 = 1;
 272   3                              error4 = (error4 == 1) ? 0 : 1;
 273   3                              dataUpdate();
 274   3                              showError(4, error4);
 275   3                              Timer0_Delay1ms(200);
 276   3                              showValue(counter);
 277   3                              if (I2C_Write(addrE4, error4))
 278   3                                      Timer0_Delay1ms(1);
 279   3                      } else if (digitalRead(BT_E4) == 1) S_BT_E4 = 0;
 280   2                      
 281   2                      
 282   2                      if ((uint32_t)(millis - led_time) >= 2000) {
 283   3                              led_time = millis;
 284   3                              //sendDataModbusRTU(dataSend, sumSize);
 285   3                              P12 = ~P12;
 286   3                      }
 287   2                      
 288   2                      if (serial_available()) {
 289   3                              uint8_t c = serial_read();
 290   3                              if ((uint32_t)(millis - serialTime) > serialTimeout) {
 291   4                                      serialTime = millis;
 292   4                                      reciveCounter = 0;
 293   4                              }
C51 COMPILER V9.60.0.0   GPIO                                                              01/12/2024 10:26:19 PAGE 6   

 294   3                              reciveData[reciveCounter] = c;
 295   3                              reciveCounter++;
 296   3                              if (reciveCounter >= 8) {
 297   4                                      reciveCounter = 0;
 298   4                                      if (reciveData[0] == id) {
 299   5                                              if (reciveData[1] == 0x3) {                             // 0x3 - READ HOLDING REGISTERS 
 300   6                                                      //dataUpdate();
 301   6                                                      sendDataModbusRTU(dataSend, sumSize);
 302   6                                              } else if (reciveData[1] == 0x6) {              // 0x6 - Single Holding Register
 303   6                                                      if (reciveData[3] == 0) {
 304   7                                                              error1 = reciveData[5];
 305   7                                                              showError(1, error1);
 306   7                                                              if (I2C_Write(addrE1, error1))
 307   7                                                                      Timer0_Delay1ms(1);
 308   7                                                      } else if (reciveData[3] == 1) {
 309   7                                                              error2 = reciveData[5];
 310   7                                                              showError(2, error2);
 311   7                                                              if (I2C_Write(addrE2, error2))
 312   7                                                                      Timer0_Delay1ms(1);
 313   7                                                      } else if (reciveData[3] == 2) {
 314   7                                                              error3 = reciveData[5];
 315   7                                                              showError(3, error3);
 316   7                                                              if (I2C_Write(addrE3, error3))
 317   7                                                                      Timer0_Delay1ms(1);
 318   7                                                      } else if (reciveData[3] == 3) {
 319   7                                                              error4 = reciveData[5];
 320   7                                                              showError(4, error4);
 321   7                                                              if (I2C_Write(addrE4, error4))
 322   7                                                                      Timer0_Delay1ms(1);
 323   7                                                      } else if (reciveData[3] == 4) {
 324   7                                                              counter = (reciveData[4] << 8) ^ reciveData[5];
 325   7                                                      } else if (reciveData[3] == 5) {
 326   7                                                              id = reciveData[5];
 327   7                                                              dataSend[0] = lowByte(id);
 328   7                                                              if (I2C_Write(addrID, id))
 329   7                                                                      Timer0_Delay1ms(1);
 330   7                                                      }
 331   6                                                      dataUpdate();
 332   6                                                      showValue(counter);
 333   6                                                      if (I2C_WriteInt(addrCNT, counter))
 334   6                                                              Timer0_Delay1ms(1);
 335   6                                              }
 336   5                                      }
 337   4                              }
 338   3                      }
 339   2              }
 340   1      }
 341          
 342          
 343          
 344          // ------------------------ END of main ------------------------------------
 345          
 346          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1617    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =     36       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10      11
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   GPIO                                                              01/12/2024 10:26:19 PAGE 7   

   BIT SIZE         =     10    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
